#ifndef SWITCH_NODE_H
#define SWITCH_NODE_H

#include <unordered_map>
#include <ns3/node.h>
#include "qbb-net-device.h"
#include "switch-mmu.h"

namespace ns3 {

class Packet;

class SwitchNode : public Node{
	std::unordered_map<uint32_t, std::vector<int> > m_rtTable; // map from ip address (u32) to possible ECMP port (index of dev)

	// monitor of PFC
	std::vector<uint32_t> m_bytes[Settings::PORTNUM][Settings::PORTNUM]; // m_bytes[inDev][outDev][qidx] is the bytes from inDev enqueued for outDev at qidx
	
	uint64_t m_txBytes[Settings::PORTNUM]; // counter of tx bytes

	bool DequeueCheckFC(uint32_t dev, uint32_t qIndex);

protected:
	bool m_ecnEnabled;
	uint32_t m_ccMode;

	uint32_t m_ackHighPrio; // set high priority for ACK/NACK

private:

	/**
	 * add by wqy on 2020/12/10
	 * For statistic
	 * \return switch total used buffer
	 */
	uint32_t DoStatistics();
	/**
	 * add by wqy on 2020/12/10
	 * For statistic
	 */
	void PrintQlength();

	EventId m_eventDoHierRR;
	void DoHierQRR();
	uint32_t MatchDefaultQ(const CustomHeader &ch);
	uint32_t MatchQ(uint32_t inDev, uint32_t outDev, CustomHeader &ch, Ptr<Packet> p);
	int GetOutDev(Ptr<const Packet>, CustomHeader &ch);
	void SendToDev(Ptr<Packet>p, CustomHeader &ch);
	uint32_t ChooseQ(Ptr<Packet>p, CustomHeader &ch, uint32_t inDev, uint32_t idx);
	void CheckAndSendPfc(uint32_t inDev, uint32_t qIndex);
	void CheckAndSendResume(uint32_t inDev, uint32_t qIndex);

	void DoSwitchSend(Ptr<Packet>p, CustomHeader &ch, uint32_t outDev, uint32_t qIndex);
	void DoDequeueVOQ(Ptr<Packet>p, CustomHeader &ch, uint32_t outDev, uint32_t qIndex);

	bool output_realtime_buffer;
	// switch_id, queue_id, all, data, voq buffer of group 1, voq buffer, switch buffer
	TracedCallback<uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t> m_traceRealtimeQueue;
	TracedCallback<uint32_t, uint32_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t> m_traceRealtimeSwitchBw;
	/*---------------------------------Congestion Isolation----------------------------------------------*/
	void ReceiveCI(CITag citag, uint32_t ingress);
	void CheckAndSendDealloc(uint32_t root_switch, uint32_t root_port);
	void ReleaseMergeCIQEntry(uint32_t root_switch, uint32_t root_port, uint32_t oport);
	bool CheckDequeueHierQ_CI(uint32_t dev, uint32_t level, uint32_t qIndex, uint32_t& next_q);
	void NotifyEnqueue_CI(uint32_t inDev, uint32_t idx, uint32_t qIndex, Ptr<Packet> p);
	void NotifyEnqueueIntoOQ_CI(uint32_t inDev, uint32_t dev, uint32_t qIndex, Ptr<Packet> p);
	void NotifyEnqueueIntoCIQ_CI(uint32_t inDev, uint32_t dev, uint32_t qIndex, Ptr<Packet> p);
	void NotifyDequeue_CI(uint32_t inDev, uint32_t dev, uint32_t qIndex, Ptr<Packet> p);
	void NotifyDequeueFromOQ_CI(uint32_t inDev, uint32_t dev, uint32_t qIndex, Ptr<Packet> p);
	void NotifyDequeueFromCIQ_CI(uint32_t inDev, uint32_t dev, uint32_t qIndex, Ptr<Packet> p);

	//get totalbytes on OQ
	uint32_t GetOQBytesTotal(uint16_t ifIndex);

	/*---------------------------------Floodgate----------------------------------------------*/
	/**
	 * add by wqy on 2020/12/8
	 * update by wqy on 2021/4/16
	 * SwitchWin mechanism:
	 * Check VOQ win and buffer packet into VOQ if necessary
	 * @return: (false: don't transfer this packet) - the switch-ACK generated by switch,
	 * 												  or data packet has no enough window and has been buffered in VOQ
	 *          (true: go on transfer this packet)
	 */
	bool CheckVOQWin(Ptr<Packet> packet, CustomHeader &ch, uint32_t inDev, uint32_t outDev, uint32_t qIndex);
	/**
	 * add by wqy on 2021/4/20
	 * When receive Switch-ACK, resume window
	 * @return: stop to transfer packet
	 */
	bool ResumeVOQWin(SwitchACKTag acktag, CustomHeader &ch, uint32_t inDev);
	/**
	 * add by wqy on 2021/4/16
	 * Send switchACK, for SWITCH_ACCUMULATE_MODE
	 */
	void SendAccSwitchACK(uint32_t inDev ,SwitchACKTag acktag);
	void SendSwitchACK(uint32_t inDev, uint32_t dst, uint32_t src, uint64_t size);
	/**
	 * add by wqy on 2021/5/26
	 * Send syn packet, for absolute psn + timeout
	 */
	void SendSYN(uint32_t dev, SwitchSYNTag syntag);
	void ReceiveSYN(SwitchSYNTag& syntag, CustomHeader &ch, uint32_t inDev);

	/*---------------------------------DRILL----------------------------------------------*/
	/**
	 * add by wqy on 2020/12/15
	 * used for DRILL
	 * When drill_load_mode == DRILL_LOAD_INTERVAL_SENT
	 * --> reset queue's statistics information every period of time
	 */
	EventId m_eventResetQueueStatitics;
	void ResetQueueStatisticsInterval();

	std::map<uint32_t, uint32_t> m_previousBestInterfaceMap;	// <dip, previousBestInterface>
	uint32_t m_drill_candidate;									// always 2 (power of two)
	/**
	 * add by wqy on 2020/12/15
	 * used for DRILL
	 * Get the load of a interface
	 */
	uint32_t CalculateInterfaceLoad (uint32_t interface);
	/**
	 * add by wqy on 2020/12/15
	 * do drill to select a egress
	 */
	uint32_t SelectEgressByDRILL(std::vector<int>& nexthops, CustomHeader &ch);


public:
	//Ptr<BroadcomNode> m_broadcom;
	Ptr<SwitchMmu> m_mmu;
	bool m_isToR;
	bool m_isCore;

	static TypeId GetTypeId (void);
	SwitchNode();
	void AddTableEntry(Ipv4Address &dstAddr, uint32_t intf_idx);
	void ClearTable();
	void CalcuUpPortsNum();
	bool SwitchReceiveFromDevice(Ptr<NetDevice> device, Ptr<Packet> packet, CustomHeader &ch);
	void SwitchNotifyDequeue(uint32_t ifIndex, uint32_t inDev, uint32_t qIndex, Ptr<Packet> p);
	void SwitchReceivePFC(uint32_t ifIndex, uint32_t qIndex, uint32_t time);
};

} /* namespace ns3 */

#endif /* SWITCH_NODE_H */
